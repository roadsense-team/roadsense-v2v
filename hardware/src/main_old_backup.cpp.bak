/**
 * @file main_packagemanager_test.cpp.bak
 * @brief PackageManager Deduplication Testing
 *
 * Tests PackageManager deduplication logic with EspNowTransport:
 * - Test 1: Duplicate detection (same timestamp → blocked)
 * - Test 2: Non-duplicate handling (different timestamps → stored)
 * - Test 3: FIFO eviction (4 messages → max 3 stored)
 * - Test 4: Timeout cleanup (60-second expiry)
 *
 * ACTIVATION INSTRUCTIONS:
 * 1. Backup current main.cpp: cp main.cpp main_backup.cpp.bak
 * 2. Activate this test: cp main_packagemanager_test.cpp.bak main.cpp
 * 3. Set VEHICLE_ID in config.h:
 *    - Unit 1 (Fedora): "V001"
 *    - Unit 2 (Windows): "V002"
 * 4. Flash both units
 * 5. Open serial monitors on both laptops (115200 baud)
 *
 * TEST PROCEDURE:
 * - Units will auto-run Tests 1-3 on startup
 * - Test 4 (timeout) runs after 70 seconds
 * - Monitor serial output for PASS/FAIL indicators
 */

#include <Arduino.h>
#include "config.h"
#include "network/transport/EspNowTransport.h"
#include "network/mesh/PackageManager.h"
#include "network/protocol/V2VMessage.h"
#include "utils/Logger.h"
#include "utils/MACHelper.h"

// ============================================================================
// GLOBAL OBJECTS
// ============================================================================

EspNowTransport* transport = nullptr;
PackageManager packageManager;
uint8_t ownMAC[6];

// ============================================================================
// STATISTICS TRACKING
// ============================================================================

struct TestStats {
    uint32_t messagesSent = 0;
    uint32_t messagesReceived = 0;
    uint32_t duplicatesBlocked = 0;
    uint32_t packagesStored = 0;
};

TestStats stats;

// ============================================================================
// TEST CONFIGURATION
// ============================================================================

// Test timing
#define TEST_1_START_DELAY_MS     5000   // Start Test 1 after 5 seconds
#define TEST_2_START_DELAY_MS     15000  // Start Test 2 after 15 seconds
#define TEST_3_START_DELAY_MS     25000  // Start Test 3 after 25 seconds
#define TEST_4_START_DELAY_MS     70000  // Start Test 4 after 70 seconds (timeout test)

#define STATS_DISPLAY_INTERVAL_MS 10000  // Display stats every 10 seconds
#define HEARTBEAT_INTERVAL_MS     1000   // LED blink every 1 second

// Test flags
bool test1_executed = false;
bool test2_executed = false;
bool test3_executed = false;
bool test4_executed = false;

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * @brief Create a test V2VMessage with specified parameters
 */
V2VMessage createTestMessage(const char* vehicleId, uint32_t timestamp, uint8_t testId) {
    V2VMessage msg;
    memset(&msg, 0, sizeof(V2VMessage));

    msg.version = 2;
    strncpy(msg.vehicleId, vehicleId, 8);
    msg.timestamp = timestamp;

    // Populate some dummy data for realism
    msg.position.lat = 32.0 + (testId * 0.001);
    msg.position.lon = 34.0 + (testId * 0.001);
    msg.position.alt = 100.0;

    msg.dynamics.speed = 20.0 + testId;
    msg.dynamics.heading = 45.0;

    msg.hopCount = 0;
    memcpy(msg.sourceMAC, ownMAC, 6);

    return msg;
}

/**
 * @brief Display PackageManager statistics
 */
void displayPackageStats() {
    Logger& logger = Logger::getInstance();

    logger.info("TEST", "========================================");
    logger.info("TEST", "PACKAGEMANAGER STATISTICS");
    logger.info("TEST", "========================================");

    // Get current package count
    uint32_t totalPackages = packageManager.getPackageCount();

    logger.info("TEST", "Total Packages Stored: " + String(totalPackages));
    logger.info("TEST", "Messages Sent: " + String(stats.messagesSent));
    logger.info("TEST", "Messages Received: " + String(stats.messagesReceived));
    logger.info("TEST", "Duplicates Blocked: " + String(stats.duplicatesBlocked));
    logger.info("TEST", "========================================");
}

/**
 * @brief Display test header
 */
void displayTestHeader(const char* testName, const char* description) {
    Logger& logger = Logger::getInstance();

    logger.info("TEST", "");
    logger.info("TEST", "████████████████████████████████████████");
    logger.info("TEST", "TEST: " + String(testName));
    logger.info("TEST", "DESC: " + String(description));
    logger.info("TEST", "████████████████████████████████████████");
}

/**
 * @brief Display test result
 */
void displayTestResult(const char* testName, bool passed, const char* reason = "") {
    Logger& logger = Logger::getInstance();

    if (passed) {
        logger.info("TEST", "✓ PASS: " + String(testName));
    } else {
        logger.error("TEST", "✗ FAIL: " + String(testName));
        if (strlen(reason) > 0) {
            logger.error("TEST", "  Reason: " + String(reason));
        }
    }
}

// ============================================================================
// ESP-NOW RECEIVE CALLBACK
// ============================================================================

void onMessageReceived(const uint8_t* data, size_t len) {
    Logger& logger = Logger::getInstance();

    stats.messagesReceived++;

    if (len != sizeof(V2VMessage)) {
        logger.error("RECV", "Invalid message size: " + String(len) + " (expected " + String(sizeof(V2VMessage)) + ")");
        return;
    }

    // Parse V2VMessage
    V2VMessage msg;
    memcpy(&msg, data, sizeof(V2VMessage));

    logger.debug("RECV", "Received from " + String(msg.vehicleId) + " (timestamp: " + String(msg.timestamp) + ")");

    // Check if this is a duplicate BEFORE adding to PackageManager
    uint32_t packageCountBefore = packageManager.getPackageCount();

    // Add to PackageManager (sourceMAC is inside the message)
    packageManager.addPackage(msg.sourceMAC, msg, msg.hopCount);

    uint32_t packageCountAfter = packageManager.getPackageCount();

    // If count didn't increase, it was a duplicate
    if (packageCountAfter == packageCountBefore) {
        stats.duplicatesBlocked++;
        logger.info("DEDUP", "✗ Duplicate blocked (timestamp: " + String(msg.timestamp) + ")");
    } else {
        stats.packagesStored++;
        logger.info("STORE", "✓ Package stored (total: " + String(packageCountAfter) + ")");
    }
}

// ============================================================================
// TEST FUNCTIONS
// ============================================================================

/**
 * @brief Test 1: Duplicate Detection
 * Send the same message twice - second should be blocked
 */
void runTest1() {
    displayTestHeader("TEST 1", "Duplicate Detection (Same Timestamp)");

    Logger& logger = Logger::getInstance();
    uint32_t timestamp = millis();

    // Send message #1
    V2VMessage msg1 = createTestMessage(VEHICLE_ID, timestamp, 1);
    transport->send((uint8_t*)&msg1, sizeof(V2VMessage));
    stats.messagesSent++;
    logger.info("TEST1", "Sent message #1 (timestamp: " + String(timestamp) + ")");

    delay(500); // Wait for message to be received

    // Send message #2 (DUPLICATE - same timestamp)
    V2VMessage msg2 = createTestMessage(VEHICLE_ID, timestamp, 2);
    transport->send((uint8_t*)&msg2, sizeof(V2VMessage));
    stats.messagesSent++;
    logger.info("TEST1", "Sent message #2 (timestamp: " + String(timestamp) + " - DUPLICATE)");

    delay(500); // Wait for processing

    // Verify: duplicatesBlocked should be >= 1
    if (stats.duplicatesBlocked >= 1) {
        displayTestResult("TEST 1", true, "Duplicate successfully blocked");
    } else {
        displayTestResult("TEST 1", false, "Duplicate was NOT blocked!");
    }

    displayPackageStats();
}

/**
 * @brief Test 2: Non-Duplicate Handling
 * Send 3 messages with DIFFERENT timestamps - all should be stored
 */
void runTest2() {
    displayTestHeader("TEST 2", "Non-Duplicate Handling (Different Timestamps)");

    Logger& logger = Logger::getInstance();
    uint32_t packageCountBefore = packageManager.getPackageCount();

    // Send 3 messages with different timestamps
    for (int i = 0; i < 3; i++) {
        uint32_t timestamp = millis() + (i * 100); // Different timestamps
        V2VMessage msg = createTestMessage(VEHICLE_ID, timestamp, 10 + i);

        transport->send((uint8_t*)&msg, sizeof(V2VMessage));
        stats.messagesSent++;
        logger.info("TEST2", "Sent message #" + String(i + 1) + " (timestamp: " + String(timestamp) + ")");

        delay(500);
    }

    delay(1000); // Wait for all messages to be processed

    uint32_t packageCountAfter = packageManager.getPackageCount();
    uint32_t newPackages = packageCountAfter - packageCountBefore;

    // Verify: should have 3 new packages (but limited by MAX_PACKAGES_PER_SOURCE)
    if (newPackages >= 3 || packageCountAfter >= 3) {
        displayTestResult("TEST 2", true, "All non-duplicate messages stored");
    } else {
        String failMsg = "Expected 3+ packages, got " + String(newPackages);
        displayTestResult("TEST 2", false, failMsg.c_str());
    }

    displayPackageStats();
}

/**
 * @brief Test 3: FIFO Eviction
 * Send 4 messages from same source - oldest should be evicted (MAX_PACKAGES_PER_SOURCE = 3)
 */
void runTest3() {
    displayTestHeader("TEST 3", "FIFO Eviction (MAX_PACKAGES_PER_SOURCE = 3)");

    Logger& logger = Logger::getInstance();

    // Clear existing packages first (simulate fresh start)
    logger.info("TEST3", "Cleaning old packages...");
    packageManager.cleanupOldPackages();

    uint32_t packageCountBefore = packageManager.getPackageCount();
    logger.info("TEST3", "Package count before test: " + String(packageCountBefore));

    // Send 4 messages with different timestamps
    for (int i = 0; i < 4; i++) {
        uint32_t timestamp = millis() + (i * 200);
        V2VMessage msg = createTestMessage(VEHICLE_ID, timestamp, 20 + i);

        transport->send((uint8_t*)&msg, sizeof(V2VMessage));
        stats.messagesSent++;
        logger.info("TEST3", "Sent message #" + String(i + 1) + " (timestamp: " + String(timestamp) + ")");

        delay(500);
    }

    delay(1000);

    uint32_t packageCountAfter = packageManager.getPackageCount();

    // Verify: should have AT MOST 3 packages per source (FIFO eviction)
    logger.info("TEST3", "Package count after sending 4 messages: " + String(packageCountAfter));

    if (packageCountAfter <= 3) {
        displayTestResult("TEST 3", true, "FIFO eviction working (max 3 packages)");
    } else {
        String failMsg = "Expected max 3 packages, got " + String(packageCountAfter);
        displayTestResult("TEST 3", false, failMsg.c_str());
    }

    displayPackageStats();
}

/**
 * @brief Test 4: Timeout Cleanup
 * Wait 60+ seconds - old packages should be removed
 */
void runTest4() {
    displayTestHeader("TEST 4", "Timeout Cleanup (60-second expiry)");

    Logger& logger = Logger::getInstance();

    uint32_t packageCountBefore = packageManager.getPackageCount();
    logger.info("TEST4", "Package count before cleanup: " + String(packageCountBefore));

    // Run cleanup (packages older than 60 seconds should be removed)
    packageManager.cleanupOldPackages();

    uint32_t packageCountAfter = packageManager.getPackageCount();
    logger.info("TEST4", "Package count after cleanup: " + String(packageCountAfter));

    uint32_t packagesRemoved = packageCountBefore - packageCountAfter;

    if (packagesRemoved > 0) {
        String successMsg = String(packagesRemoved) + " old packages removed";
        displayTestResult("TEST 4", true, successMsg.c_str());
    } else {
        logger.warning("TEST4", "No packages expired (may be expected if tests ran <60 sec ago)");
        displayTestResult("TEST 4", true, "Cleanup executed (no packages old enough to expire)");
    }

    displayPackageStats();
}

// ============================================================================
// ARDUINO SETUP
// ============================================================================

void setup() {
    Serial.begin(SERIAL_BAUD_RATE);
    delay(1000);

    Logger& logger = Logger::getInstance();
    logger.begin(SERIAL_BAUD_RATE);  // ← FIX: Initialize logger
    logger.setLogLevel(LOG_DEBUG);    // ← Enable all log levels

    // Print banner
    logger.info("SETUP", "========================================");
    logger.info("SETUP", "PACKAGEMANAGER DEDUPLICATION TEST");
    logger.info("SETUP", "Vehicle ID: " + String(VEHICLE_ID));
    logger.info("SETUP", "Build: " + String(__DATE__) + " " + String(__TIME__));
    logger.info("SETUP", "========================================");

    // ⚠️ CRITICAL: Verify VEHICLE_ID is set correctly
    logger.warning("SETUP", "⚠️ CRITICAL: Verify VEHICLE_ID in config.h!");
    logger.warning("SETUP", "   Unit 1 (Fedora): V001");
    logger.warning("SETUP", "   Unit 2 (Windows): V002");
    logger.warning("SETUP", "========================================");

    // Initialize LED
    pinMode(LED_STATUS_PIN, OUTPUT);
    digitalWrite(LED_STATUS_PIN, HIGH);

    // Get own MAC address
    WiFi.macAddress(ownMAC);
    logger.info("SETUP", "MAC Address: " + MACHelper::macToString(ownMAC));

    // Initialize transport
    logger.info("SETUP", "Initializing EspNowTransport...");
    transport = new EspNowTransport(ESPNOW_CHANNEL);

    if (!transport->begin()) {
        logger.error("SETUP", "❌ EspNowTransport init FAILED!");
        while (1) {
            digitalWrite(LED_STATUS_PIN, !digitalRead(LED_STATUS_PIN));
            delay(LED_BLINK_ERROR);
        }
    }

    // Register receive callback
    transport->onReceive(onMessageReceived);

    logger.info("SETUP", "✓ EspNowTransport initialized");
    logger.info("SETUP", "✓ PackageManager initialized");
    logger.info("SETUP", "========================================");
    logger.info("SETUP", "TEST SCHEDULE:");
    logger.info("SETUP", "  Test 1 (Duplicate):   +5 sec");
    logger.info("SETUP", "  Test 2 (Non-dup):     +15 sec");
    logger.info("SETUP", "  Test 3 (FIFO):        +25 sec");
    logger.info("SETUP", "  Test 4 (Timeout):     +70 sec");
    logger.info("SETUP", "  Stats Display:        Every 10 sec");
    logger.info("SETUP", "========================================");
    logger.info("SETUP", "Waiting for tests to start...");
}

// ============================================================================
// ARDUINO LOOP
// ============================================================================

void loop() {
    static unsigned long lastStatsTime = 0;
    static unsigned long lastHeartbeatTime = 0;

    unsigned long now = millis();

    // Heartbeat LED (1 Hz)
    if (now - lastHeartbeatTime >= HEARTBEAT_INTERVAL_MS) {
        lastHeartbeatTime = now;
        digitalWrite(LED_STATUS_PIN, !digitalRead(LED_STATUS_PIN));
    }

    // Test 1: Duplicate Detection (after 5 seconds)
    if (!test1_executed && now >= TEST_1_START_DELAY_MS) {
        test1_executed = true;
        runTest1();
    }

    // Test 2: Non-Duplicate Handling (after 15 seconds)
    if (!test2_executed && now >= TEST_2_START_DELAY_MS) {
        test2_executed = true;
        runTest2();
    }

    // Test 3: FIFO Eviction (after 25 seconds)
    if (!test3_executed && now >= TEST_3_START_DELAY_MS) {
        test3_executed = true;
        runTest3();
    }

    // Test 4: Timeout Cleanup (after 70 seconds)
    if (!test4_executed && now >= TEST_4_START_DELAY_MS) {
        test4_executed = true;
        runTest4();
    }

    // Display stats periodically
    if (now - lastStatsTime >= STATS_DISPLAY_INTERVAL_MS) {
        lastStatsTime = now;
        displayPackageStats();
    }

    // Small delay to prevent watchdog issues
    delay(10);
}
